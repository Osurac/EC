   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"gpio.c"
  21              	.Ltext0:
  22              		.file 1 "../gpio.c"
 1698              		.align	2
 1699              		.global	portB_conf
 1701              	portB_conf:
 1702              	.LFB0:
   1:../gpio.c     **** ﻿#include "44b.h"
   2:../gpio.c     **** #include "gpio.h"
   3:../gpio.c     **** 
   4:../gpio.c     **** /* Port B interface implementation */
   5:../gpio.c     **** 
   6:../gpio.c     **** int portB_conf(int pin, enum port_mode mode)
   7:../gpio.c     **** {
 1703              		.loc 1 7 0
 1704              		.cfi_startproc
 1705              		@ Function supports interworking.
 1706              		@ args = 0, pretend = 0, frame = 16
 1707              		@ frame_needed = 1, uses_anonymous_args = 0
 1708 0000 0DC0A0E1 		mov	ip, sp
 1709              	.LCFI0:
 1710              		.cfi_def_cfa_register 12
 1711 0004 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1712 0008 04B04CE2 		sub	fp, ip, #4
 1713              		.cfi_offset 14, -8
 1714              		.cfi_offset 13, -12
 1715              		.cfi_offset 11, -16
 1716              	.LCFI1:
 1717              		.cfi_def_cfa 11, 4
 1718 000c 10D04DE2 		sub	sp, sp, #16
 1719 0010 18000BE5 		str	r0, [fp, #-24]
 1720 0014 0130A0E1 		mov	r3, r1
 1721 0018 19304BE5 		strb	r3, [fp, #-25]
   8:../gpio.c     **** 	int ret = 0;
 1722              		.loc 1 8 0
 1723 001c 0030A0E3 		mov	r3, #0
 1724 0020 10300BE5 		str	r3, [fp, #-16]
   9:../gpio.c     **** 	if (pin < 0 || pin > 10)
 1725              		.loc 1 9 0
 1726 0024 18301BE5 		ldr	r3, [fp, #-24]
 1727 0028 000053E3 		cmp	r3, #0
 1728 002c 020000BA 		blt	.L2
 1729              		.loc 1 9 0 is_stmt 0 discriminator 1
 1730 0030 18301BE5 		ldr	r3, [fp, #-24]
 1731 0034 0A0053E3 		cmp	r3, #10
 1732 0038 010000DA 		ble	.L3
 1733              	.L2:
  10:../gpio.c     **** 		return -1; // indica error
 1734              		.loc 1 10 0 is_stmt 1
 1735 003c 0030E0E3 		mvn	r3, #0
 1736 0040 080000EA 		b	.L4
 1737              	.L3:
  11:../gpio.c     **** 
  12:../gpio.c     **** 	if (mode == SIGOUT){
 1738              		.loc 1 12 0
 1739 0044 19305BE5 		ldrb	r3, [fp, #-25]	@ zero_extendqisi2
 1740 0048 020053E3 		cmp	r3, #2
 1741 004c 0400000A 		beq	.L5
  13:../gpio.c     **** 		// COMPLETAR: poner en rPCONB el bit indicado por pin a 1 para que por
  14:../gpio.c     **** 		// dicho pin en el puerto B salga la señal correspondiente del
  15:../gpio.c     **** 		// controlador de memoria
  16:../gpio.c     **** 	}else if (mode == OUTPUT){
 1742              		.loc 1 16 0
 1743 0050 19305BE5 		ldrb	r3, [fp, #-25]	@ zero_extendqisi2
 1744 0054 010053E3 		cmp	r3, #1
 1745 0058 0100000A 		beq	.L5
  17:../gpio.c     **** 		// COMPLETAR: poner en rPCONB el bit indicado por pin a 0 para que dicho
  18:../gpio.c     **** 		// pin sea un pin de salida
  19:../gpio.c     **** 	}else{
  20:../gpio.c     **** 		ret = -1; // indica error
 1746              		.loc 1 20 0
 1747 005c 0030E0E3 		mvn	r3, #0
 1748 0060 10300BE5 		str	r3, [fp, #-16]
 1749              	.L5:
  21:../gpio.c     **** 	}
  22:../gpio.c     **** 	return ret;
 1750              		.loc 1 22 0
 1751 0064 10301BE5 		ldr	r3, [fp, #-16]
 1752              	.L4:
  23:../gpio.c     **** }
 1753              		.loc 1 23 0
 1754 0068 0300A0E1 		mov	r0, r3
 1755 006c 0CD04BE2 		sub	sp, fp, #12
 1756 0070 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1757 0074 1EFF2FE1 		bx	lr
 1758              		.cfi_endproc
 1759              	.LFE0:
 1761              		.align	2
 1762              		.global	portB_write
 1764              	portB_write:
 1765              	.LFB1:
  24:../gpio.c     **** 
  25:../gpio.c     **** int portB_write(int pin, enum digital val)
  26:../gpio.c     **** {
 1766              		.loc 1 26 0
 1767              		.cfi_startproc
 1768              		@ Function supports interworking.
 1769              		@ args = 0, pretend = 0, frame = 8
 1770              		@ frame_needed = 1, uses_anonymous_args = 0
 1771 0078 0DC0A0E1 		mov	ip, sp
 1772              	.LCFI2:
 1773              		.cfi_def_cfa_register 12
 1774 007c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1775 0080 04B04CE2 		sub	fp, ip, #4
 1776              		.cfi_offset 14, -8
 1777              		.cfi_offset 13, -12
 1778              		.cfi_offset 11, -16
 1779              	.LCFI3:
 1780              		.cfi_def_cfa 11, 4
 1781 0084 08D04DE2 		sub	sp, sp, #8
 1782 0088 10000BE5 		str	r0, [fp, #-16]
 1783 008c 0130A0E1 		mov	r3, r1
 1784 0090 11304BE5 		strb	r3, [fp, #-17]
  27:../gpio.c     **** 	if (pin < 0 || pin > 10)
 1785              		.loc 1 27 0
 1786 0094 10301BE5 		ldr	r3, [fp, #-16]
 1787 0098 000053E3 		cmp	r3, #0
 1788 009c 020000BA 		blt	.L7
 1789              		.loc 1 27 0 is_stmt 0 discriminator 1
 1790 00a0 10301BE5 		ldr	r3, [fp, #-16]
 1791 00a4 0A0053E3 		cmp	r3, #10
 1792 00a8 010000DA 		ble	.L8
 1793              	.L7:
  28:../gpio.c     **** 		return -1; // indica error
 1794              		.loc 1 28 0 is_stmt 1
 1795 00ac 0030E0E3 		mvn	r3, #0
 1796 00b0 050000EA 		b	.L9
 1797              	.L8:
  29:../gpio.c     **** 
  30:../gpio.c     **** 	if (val < 0 || val > 1)
 1798              		.loc 1 30 0
 1799 00b4 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 1800 00b8 010053E3 		cmp	r3, #1
 1801 00bc 0100009A 		bls	.L10
  31:../gpio.c     **** 		return -1; // indica error
 1802              		.loc 1 31 0
 1803 00c0 0030E0E3 		mvn	r3, #0
 1804 00c4 000000EA 		b	.L9
 1805              	.L10:
  32:../gpio.c     **** 
  33:../gpio.c     **** 	if (val){
  34:../gpio.c     **** 		// COMPLETAR: poner en rPDATB el bit indicado por pin a 1
  35:../gpio.c     **** 	}else{
  36:../gpio.c     **** 		// COMPLETAR: poner en rPDATB el bit indicado por pin a 0
  37:../gpio.c     **** 	}
  38:../gpio.c     **** 	return 0;
 1806              		.loc 1 38 0
 1807 00c8 0030A0E3 		mov	r3, #0
 1808              	.L9:
  39:../gpio.c     **** }
 1809              		.loc 1 39 0
 1810 00cc 0300A0E1 		mov	r0, r3
 1811 00d0 0CD04BE2 		sub	sp, fp, #12
 1812 00d4 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1813 00d8 1EFF2FE1 		bx	lr
 1814              		.cfi_endproc
 1815              	.LFE1:
 1817              		.align	2
 1818              		.global	portG_conf
 1820              	portG_conf:
 1821              	.LFB2:
  40:../gpio.c     **** 
  41:../gpio.c     **** /* Port G interface implementation */
  42:../gpio.c     **** 
  43:../gpio.c     **** int portG_conf(int pin, enum port_mode mode)
  44:../gpio.c     **** {
 1822              		.loc 1 44 0
 1823              		.cfi_startproc
 1824              		@ Function supports interworking.
 1825              		@ args = 0, pretend = 0, frame = 16
 1826              		@ frame_needed = 1, uses_anonymous_args = 0
 1827 00dc 0DC0A0E1 		mov	ip, sp
 1828              	.LCFI4:
 1829              		.cfi_def_cfa_register 12
 1830 00e0 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1831 00e4 04B04CE2 		sub	fp, ip, #4
 1832              		.cfi_offset 14, -8
 1833              		.cfi_offset 13, -12
 1834              		.cfi_offset 11, -16
 1835              	.LCFI5:
 1836              		.cfi_def_cfa 11, 4
 1837 00e8 10D04DE2 		sub	sp, sp, #16
 1838 00ec 18000BE5 		str	r0, [fp, #-24]
 1839 00f0 0130A0E1 		mov	r3, r1
 1840 00f4 19304BE5 		strb	r3, [fp, #-25]
  45:../gpio.c     **** 	int pos  = pin*2;
 1841              		.loc 1 45 0
 1842 00f8 18301BE5 		ldr	r3, [fp, #-24]
 1843 00fc 8330A0E1 		mov	r3, r3, asl #1
 1844 0100 10300BE5 		str	r3, [fp, #-16]
  46:../gpio.c     **** 
  47:../gpio.c     **** 	if (pin < 0 || pin > 7)
 1845              		.loc 1 47 0
 1846 0104 18301BE5 		ldr	r3, [fp, #-24]
 1847 0108 000053E3 		cmp	r3, #0
 1848 010c 020000BA 		blt	.L12
 1849              		.loc 1 47 0 is_stmt 0 discriminator 1
 1850 0110 18301BE5 		ldr	r3, [fp, #-24]
 1851 0114 070053E3 		cmp	r3, #7
 1852 0118 010000DA 		ble	.L13
 1853              	.L12:
  48:../gpio.c     **** 		return -1; // indica error
 1854              		.loc 1 48 0 is_stmt 1
 1855 011c 0030E0E3 		mvn	r3, #0
 1856 0120 0B0000EA 		b	.L14
 1857              	.L13:
  49:../gpio.c     **** 
  50:../gpio.c     **** 	switch (mode) {
 1858              		.loc 1 50 0
 1859 0124 19305BE5 		ldrb	r3, [fp, #-25]	@ zero_extendqisi2
 1860 0128 030053E3 		cmp	r3, #3
 1861 012c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1862 0130 030000EA 		b	.L15
 1863              	.L20:
 1864 0134 4C010000 		.word	.L22
 1865 0138 4C010000 		.word	.L22
 1866 013c 4C010000 		.word	.L22
 1867 0140 4C010000 		.word	.L22
 1868              	.L15:
  51:../gpio.c     **** 		case INPUT:
  52:../gpio.c     **** 			// COMPLETAR: poner en rPCONG 00 a partir de la posición pos para
  53:../gpio.c     **** 			// configurar como pin de entrada el pin indicado por el parámetro pin
  54:../gpio.c     **** 			break;
  55:../gpio.c     **** 		case OUTPUT:
  56:../gpio.c     **** 			// COMPLETAR: poner en rPCONG 01 a partir de la posición pos para
  57:../gpio.c     **** 			// configurar como pin de salida el pin indicado por el parámetro pin
  58:../gpio.c     **** 			break;
  59:../gpio.c     **** 		case SIGOUT:
  60:../gpio.c     **** 			// COMPLETAR: poner en rPCONG 10 a partir de la posición pos para
  61:../gpio.c     **** 			// que salga la señal interna correspondiente por el pin indicado
  62:../gpio.c     **** 			// por el parámetro pin
  63:../gpio.c     **** 			break;
  64:../gpio.c     **** 		case EINT:
  65:../gpio.c     **** 			// COMPLETAR: poner en rPCONG 11 a partir de la posición pos para
  66:../gpio.c     **** 			// habilitar la generación de interrupciones externas por el pin
  67:../gpio.c     **** 			// indicado por el parámetro pin
  68:../gpio.c     **** 			break;
  69:../gpio.c     **** 		default:
  70:../gpio.c     **** 			return -1;
 1869              		.loc 1 70 0
 1870 0144 0030E0E3 		mvn	r3, #0
 1871 0148 010000EA 		b	.L14
 1872              	.L22:
  54:../gpio.c     **** 			break;
 1873              		.loc 1 54 0
 1874 014c 0000A0E1 		mov	r0, r0	@ nop
 1875              	.L21:
  71:../gpio.c     **** 	}
  72:../gpio.c     **** 
  73:../gpio.c     **** 	return 0;
 1876              		.loc 1 73 0
 1877 0150 0030A0E3 		mov	r3, #0
 1878              	.L14:
  74:../gpio.c     **** }
 1879              		.loc 1 74 0
 1880 0154 0300A0E1 		mov	r0, r3
 1881 0158 0CD04BE2 		sub	sp, fp, #12
 1882 015c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1883 0160 1EFF2FE1 		bx	lr
 1884              		.cfi_endproc
 1885              	.LFE2:
 1887              		.align	2
 1888              		.global	portG_eint_trig
 1890              	portG_eint_trig:
 1891              	.LFB3:
  75:../gpio.c     **** 
  76:../gpio.c     **** int portG_eint_trig(int pin, enum trigger trig)
  77:../gpio.c     **** {
 1892              		.loc 1 77 0
 1893              		.cfi_startproc
 1894              		@ Function supports interworking.
 1895              		@ args = 0, pretend = 0, frame = 8
 1896              		@ frame_needed = 1, uses_anonymous_args = 0
 1897 0164 0DC0A0E1 		mov	ip, sp
 1898              	.LCFI6:
 1899              		.cfi_def_cfa_register 12
 1900 0168 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1901 016c 04B04CE2 		sub	fp, ip, #4
 1902              		.cfi_offset 14, -8
 1903              		.cfi_offset 13, -12
 1904              		.cfi_offset 11, -16
 1905              	.LCFI7:
 1906              		.cfi_def_cfa 11, 4
 1907 0170 08D04DE2 		sub	sp, sp, #8
 1908 0174 10000BE5 		str	r0, [fp, #-16]
 1909 0178 0130A0E1 		mov	r3, r1
 1910 017c 11304BE5 		strb	r3, [fp, #-17]
  78:../gpio.c     **** 	// A COMPLETAR EN LA SEGUNDA PARTE DE LA PRÁCTICA
  79:../gpio.c     **** 	return 0;
 1911              		.loc 1 79 0
 1912 0180 0030A0E3 		mov	r3, #0
  80:../gpio.c     **** }
 1913              		.loc 1 80 0
 1914 0184 0300A0E1 		mov	r0, r3
 1915 0188 0CD04BE2 		sub	sp, fp, #12
 1916 018c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1917 0190 1EFF2FE1 		bx	lr
 1918              		.cfi_endproc
 1919              	.LFE3:
 1921              		.align	2
 1922              		.global	portG_write
 1924              	portG_write:
 1925              	.LFB4:
  81:../gpio.c     **** 
  82:../gpio.c     **** int portG_write(int pin, enum digital val)
  83:../gpio.c     **** {
 1926              		.loc 1 83 0
 1927              		.cfi_startproc
 1928              		@ Function supports interworking.
 1929              		@ args = 0, pretend = 0, frame = 16
 1930              		@ frame_needed = 1, uses_anonymous_args = 0
 1931 0194 0DC0A0E1 		mov	ip, sp
 1932              	.LCFI8:
 1933              		.cfi_def_cfa_register 12
 1934 0198 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1935 019c 04B04CE2 		sub	fp, ip, #4
 1936              		.cfi_offset 14, -8
 1937              		.cfi_offset 13, -12
 1938              		.cfi_offset 11, -16
 1939              	.LCFI9:
 1940              		.cfi_def_cfa 11, 4
 1941 01a0 10D04DE2 		sub	sp, sp, #16
 1942 01a4 18000BE5 		str	r0, [fp, #-24]
 1943 01a8 0130A0E1 		mov	r3, r1
 1944 01ac 19304BE5 		strb	r3, [fp, #-25]
  84:../gpio.c     **** 	int pos = pin*2;
 1945              		.loc 1 84 0
 1946 01b0 18301BE5 		ldr	r3, [fp, #-24]
 1947 01b4 8330A0E1 		mov	r3, r3, asl #1
 1948 01b8 10300BE5 		str	r3, [fp, #-16]
  85:../gpio.c     **** 
  86:../gpio.c     **** 	if (pin < 0 || pin > 7)
 1949              		.loc 1 86 0
 1950 01bc 18301BE5 		ldr	r3, [fp, #-24]
 1951 01c0 000053E3 		cmp	r3, #0
 1952 01c4 020000BA 		blt	.L25
 1953              		.loc 1 86 0 is_stmt 0 discriminator 1
 1954 01c8 18301BE5 		ldr	r3, [fp, #-24]
 1955 01cc 070053E3 		cmp	r3, #7
 1956 01d0 010000DA 		ble	.L26
 1957              	.L25:
  87:../gpio.c     **** 		return -1; // indica error
 1958              		.loc 1 87 0 is_stmt 1
 1959 01d4 0030E0E3 		mvn	r3, #0
 1960 01d8 120000EA 		b	.L27
 1961              	.L26:
  88:../gpio.c     **** 
  89:../gpio.c     **** 	if (val < 0 || val > 1)
 1962              		.loc 1 89 0
 1963 01dc 19305BE5 		ldrb	r3, [fp, #-25]	@ zero_extendqisi2
 1964 01e0 010053E3 		cmp	r3, #1
 1965 01e4 0100009A 		bls	.L28
  90:../gpio.c     **** 		return -1; // indica error
 1966              		.loc 1 90 0
 1967 01e8 0030E0E3 		mvn	r3, #0
 1968 01ec 0D0000EA 		b	.L27
 1969              	.L28:
  91:../gpio.c     **** 
  92:../gpio.c     **** 	if ((rPCONG & (0x3 << pos)) != (0x1 << pos))
 1970              		.loc 1 92 0
 1971 01f0 40309FE5 		ldr	r3, .L30
 1972 01f4 002093E5 		ldr	r2, [r3, #0]
 1973 01f8 0310A0E3 		mov	r1, #3
 1974 01fc 10301BE5 		ldr	r3, [fp, #-16]
 1975 0200 1133A0E1 		mov	r3, r1, asl r3
 1976 0204 032002E0 		and	r2, r2, r3
 1977 0208 0110A0E3 		mov	r1, #1
 1978 020c 10301BE5 		ldr	r3, [fp, #-16]
 1979 0210 1133A0E1 		mov	r3, r1, asl r3
 1980 0214 030052E1 		cmp	r2, r3
 1981 0218 0100000A 		beq	.L29
  93:../gpio.c     **** 		return -1; // indica error
 1982              		.loc 1 93 0
 1983 021c 0030E0E3 		mvn	r3, #0
 1984 0220 000000EA 		b	.L27
 1985              	.L29:
  94:../gpio.c     **** 
  95:../gpio.c     **** 	if (val){
  96:../gpio.c     **** 		// COMPLETAR: poner en rPDATG el bit indicado por pin a 1
  97:../gpio.c     **** 	}else{
  98:../gpio.c     **** 		// COMPLETAR: poner en rPDATG el bit indicado por pin a 0
  99:../gpio.c     **** 	}
 100:../gpio.c     **** 	return 0;
 1986              		.loc 1 100 0
 1987 0224 0030A0E3 		mov	r3, #0
 1988              	.L27:
 101:../gpio.c     **** }
 1989              		.loc 1 101 0
 1990 0228 0300A0E1 		mov	r0, r3
 1991 022c 0CD04BE2 		sub	sp, fp, #12
 1992 0230 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1993 0234 1EFF2FE1 		bx	lr
 1994              	.L31:
 1995              		.align	2
 1996              	.L30:
 1997 0238 4000D201 		.word	30539840
 1998              		.cfi_endproc
 1999              	.LFE4:
 2001              		.align	2
 2002              		.global	portG_read
 2004              	portG_read:
 2005              	.LFB5:
 102:../gpio.c     **** 
 103:../gpio.c     **** int portG_read(int pin, enum digital* val)
 104:../gpio.c     **** {
 2006              		.loc 1 104 0
 2007              		.cfi_startproc
 2008              		@ Function supports interworking.
 2009              		@ args = 0, pretend = 0, frame = 16
 2010              		@ frame_needed = 1, uses_anonymous_args = 0
 2011 023c 0DC0A0E1 		mov	ip, sp
 2012              	.LCFI10:
 2013              		.cfi_def_cfa_register 12
 2014 0240 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2015 0244 04B04CE2 		sub	fp, ip, #4
 2016              		.cfi_offset 14, -8
 2017              		.cfi_offset 13, -12
 2018              		.cfi_offset 11, -16
 2019              	.LCFI11:
 2020              		.cfi_def_cfa 11, 4
 2021 0248 10D04DE2 		sub	sp, sp, #16
 2022 024c 18000BE5 		str	r0, [fp, #-24]
 2023 0250 1C100BE5 		str	r1, [fp, #-28]
 105:../gpio.c     **** 	int pos = pin*2;
 2024              		.loc 1 105 0
 2025 0254 18301BE5 		ldr	r3, [fp, #-24]
 2026 0258 8330A0E1 		mov	r3, r3, asl #1
 2027 025c 10300BE5 		str	r3, [fp, #-16]
 106:../gpio.c     **** 
 107:../gpio.c     **** 	if (pin < 0 || pin > 7)
 2028              		.loc 1 107 0
 2029 0260 18301BE5 		ldr	r3, [fp, #-24]
 2030 0264 000053E3 		cmp	r3, #0
 2031 0268 020000BA 		blt	.L33
 2032              		.loc 1 107 0 is_stmt 0 discriminator 1
 2033 026c 18301BE5 		ldr	r3, [fp, #-24]
 2034 0270 070053E3 		cmp	r3, #7
 2035 0274 010000DA 		ble	.L34
 2036              	.L33:
 108:../gpio.c     **** 		return -1; // indica error
 2037              		.loc 1 108 0 is_stmt 1
 2038 0278 0030E0E3 		mvn	r3, #0
 2039 027c 190000EA 		b	.L35
 2040              	.L34:
 109:../gpio.c     **** 
 110:../gpio.c     **** 	if (rPCONG & (0x3 << pos))
 2041              		.loc 1 110 0
 2042 0280 70309FE5 		ldr	r3, .L39
 2043 0284 002093E5 		ldr	r2, [r3, #0]
 2044 0288 0310A0E3 		mov	r1, #3
 2045 028c 10301BE5 		ldr	r3, [fp, #-16]
 2046 0290 1133A0E1 		mov	r3, r1, asl r3
 2047 0294 033002E0 		and	r3, r2, r3
 2048 0298 000053E3 		cmp	r3, #0
 2049 029c 0100000A 		beq	.L36
 111:../gpio.c     **** 		return -1; // indica error
 2050              		.loc 1 111 0
 2051 02a0 0030E0E3 		mvn	r3, #0
 2052 02a4 0F0000EA 		b	.L35
 2053              	.L36:
 112:../gpio.c     **** 	/*COMPLETAR: true si está a 1 en rPDATG el pin indicado por el parámetro pin*/
 113:../gpio.c     **** 
 114:../gpio.c     **** 	if(rPCONG & (0x3 << pos)){
 2054              		.loc 1 114 0
 2055 02a8 48309FE5 		ldr	r3, .L39
 2056 02ac 002093E5 		ldr	r2, [r3, #0]
 2057 02b0 0310A0E3 		mov	r1, #3
 2058 02b4 10301BE5 		ldr	r3, [fp, #-16]
 2059 02b8 1133A0E1 		mov	r3, r1, asl r3
 2060 02bc 033002E0 		and	r3, r2, r3
 2061 02c0 000053E3 		cmp	r3, #0
 2062 02c4 0300000A 		beq	.L37
 115:../gpio.c     **** 		*val = HIGH;
 2063              		.loc 1 115 0
 2064 02c8 1C301BE5 		ldr	r3, [fp, #-28]
 2065 02cc 0120A0E3 		mov	r2, #1
 2066 02d0 0020C3E5 		strb	r2, [r3, #0]
 2067 02d4 020000EA 		b	.L38
 2068              	.L37:
 116:../gpio.c     **** 	}else{
 117:../gpio.c     **** 		*val = LOW;
 2069              		.loc 1 117 0
 2070 02d8 1C301BE5 		ldr	r3, [fp, #-28]
 2071 02dc 0020A0E3 		mov	r2, #0
 2072 02e0 0020C3E5 		strb	r2, [r3, #0]
 2073              	.L38:
 118:../gpio.c     **** 	}
 119:../gpio.c     **** 	return 0;
 2074              		.loc 1 119 0
 2075 02e4 0030A0E3 		mov	r3, #0
 2076              	.L35:
 120:../gpio.c     **** }
 2077              		.loc 1 120 0
 2078 02e8 0300A0E1 		mov	r0, r3
 2079 02ec 0CD04BE2 		sub	sp, fp, #12
 2080 02f0 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2081 02f4 1EFF2FE1 		bx	lr
 2082              	.L40:
 2083              		.align	2
 2084              	.L39:
 2085 02f8 4000D201 		.word	30539840
 2086              		.cfi_endproc
 2087              	.LFE5:
 2089              		.align	2
 2090              		.global	portG_conf_pup
 2092              	portG_conf_pup:
 2093              	.LFB6:
 121:../gpio.c     **** 
 122:../gpio.c     **** int portG_conf_pup(int pin, enum enable st)
 123:../gpio.c     **** {
 2094              		.loc 1 123 0
 2095              		.cfi_startproc
 2096              		@ Function supports interworking.
 2097              		@ args = 0, pretend = 0, frame = 8
 2098              		@ frame_needed = 1, uses_anonymous_args = 0
 2099 02fc 0DC0A0E1 		mov	ip, sp
 2100              	.LCFI12:
 2101              		.cfi_def_cfa_register 12
 2102 0300 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2103 0304 04B04CE2 		sub	fp, ip, #4
 2104              		.cfi_offset 14, -8
 2105              		.cfi_offset 13, -12
 2106              		.cfi_offset 11, -16
 2107              	.LCFI13:
 2108              		.cfi_def_cfa 11, 4
 2109 0308 08D04DE2 		sub	sp, sp, #8
 2110 030c 10000BE5 		str	r0, [fp, #-16]
 2111 0310 0130A0E1 		mov	r3, r1
 2112 0314 11304BE5 		strb	r3, [fp, #-17]
 124:../gpio.c     **** 	if (pin < 0 || pin > 7)
 2113              		.loc 1 124 0
 2114 0318 10301BE5 		ldr	r3, [fp, #-16]
 2115 031c 000053E3 		cmp	r3, #0
 2116 0320 020000BA 		blt	.L42
 2117              		.loc 1 124 0 is_stmt 0 discriminator 1
 2118 0324 10301BE5 		ldr	r3, [fp, #-16]
 2119 0328 070053E3 		cmp	r3, #7
 2120 032c 010000DA 		ble	.L43
 2121              	.L42:
 125:../gpio.c     **** 		return -1; // indica error
 2122              		.loc 1 125 0 is_stmt 1
 2123 0330 0030E0E3 		mvn	r3, #0
 2124 0334 080000EA 		b	.L44
 2125              	.L43:
 126:../gpio.c     **** 
 127:../gpio.c     **** 	if (st != ENABLE && st != DISABLE)
 2126              		.loc 1 127 0
 2127 0338 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 2128 033c 010053E3 		cmp	r3, #1
 2129 0340 0400000A 		beq	.L45
 2130              		.loc 1 127 0 is_stmt 0 discriminator 1
 2131 0344 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 2132 0348 000053E3 		cmp	r3, #0
 2133 034c 0100000A 		beq	.L45
 128:../gpio.c     **** 		return -1; // indica error
 2134              		.loc 1 128 0 is_stmt 1
 2135 0350 0030E0E3 		mvn	r3, #0
 2136 0354 000000EA 		b	.L44
 2137              	.L45:
 129:../gpio.c     **** 	if(st == ENABLE){
 130:../gpio.c     **** 		// COMPLETAR: poner el pin de rPUPG indicado por el parametro pin al valor adecuado,
 131:../gpio.c     **** 		// para activar la resistencia de pull-up
 132:../gpio.c     **** 	}else{
 133:../gpio.c     **** 		// COMPLETAR: poner el pin de rPUPG indicado por el parametro pin al valor adecuado,
 134:../gpio.c     **** 		// para desactivar la resistencia de pull-up
 135:../gpio.c     **** 	}
 136:../gpio.c     **** 	return 0;
 2138              		.loc 1 136 0
 2139 0358 0030A0E3 		mov	r3, #0
 2140              	.L44:
 137:../gpio.c     **** 
 138:../gpio.c     **** }
 2141              		.loc 1 138 0
 2142 035c 0300A0E1 		mov	r0, r3
 2143 0360 0CD04BE2 		sub	sp, fp, #12
 2144 0364 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2145 0368 1EFF2FE1 		bx	lr
 2146              		.cfi_endproc
 2147              	.LFE6:
 2149              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 gpio.c
C:\Users\Osurac\AppData\Local\Temp\ccS0g8pP.s:1698   .text:00000000 $a
C:\Users\Osurac\AppData\Local\Temp\ccS0g8pP.s:1701   .text:00000000 portB_conf
C:\Users\Osurac\AppData\Local\Temp\ccS0g8pP.s:1764   .text:00000078 portB_write
C:\Users\Osurac\AppData\Local\Temp\ccS0g8pP.s:1820   .text:000000dc portG_conf
C:\Users\Osurac\AppData\Local\Temp\ccS0g8pP.s:1864   .text:00000134 $d
C:\Users\Osurac\AppData\Local\Temp\ccS0g8pP.s:1870   .text:00000144 $a
C:\Users\Osurac\AppData\Local\Temp\ccS0g8pP.s:1890   .text:00000164 portG_eint_trig
C:\Users\Osurac\AppData\Local\Temp\ccS0g8pP.s:1924   .text:00000194 portG_write
C:\Users\Osurac\AppData\Local\Temp\ccS0g8pP.s:1997   .text:00000238 $d
C:\Users\Osurac\AppData\Local\Temp\ccS0g8pP.s:2001   .text:0000023c $a
C:\Users\Osurac\AppData\Local\Temp\ccS0g8pP.s:2004   .text:0000023c portG_read
C:\Users\Osurac\AppData\Local\Temp\ccS0g8pP.s:2085   .text:000002f8 $d
C:\Users\Osurac\AppData\Local\Temp\ccS0g8pP.s:2089   .text:000002fc $a
C:\Users\Osurac\AppData\Local\Temp\ccS0g8pP.s:2092   .text:000002fc portG_conf_pup
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
